<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini API ê¸°ë°˜ ì˜ì–´ ìˆ˜ì—…ë…¸íŠ¸ ìƒì„±ê¸° (3ì¢… ì„¸íŠ¸) âœï¸</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/docx@7.1.0/build/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fonts-archive/Paperlogy/Paperlogy.css" type="text/css"/>

    <style>
        /* Paperlogy í°íŠ¸ ë¡œë“œ */
        /* CDN link in <head> is now used, so @font-face here is not strictly necessary unless for fallback or specific weights */

        /* ì „ì—­ í°íŠ¸ ë° ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
        html, body {
            font-family: 'Paperlogy', 'Noto Sans KR', 'Malgun Gothic', sans-serif; 
            padding: 20px;
            background-color: #fdfaef; /* ë¶€ë“œëŸ¬ìš´ ì¢…ì´ ì§ˆê° ë°°ê²½ */
            color: #4a3f35; /* ì§™ì€ ê°ˆìƒ‰ í…ìŠ¤íŠ¸ */
            font-size: 16px; 
            line-height: 1.65; 
        }
        .container {
            background-color: #fffaf0; 
            padding: 35px;
            border-radius: 12px; 
            box-shadow: 0 8px 25px rgba(0,0,0,0.08); 
            border: 1px solid #eee0c4; 
        }
        .app-title {
            font-size: 2.8rem; 
            font-weight: normal; 
            color: #5d4037; 
            margin-bottom: 30px;
            text-align: center;
        }
        .app-title .emoji {
            font-size: 3rem;
            margin-left: 10px;
        }

        /* ì»¨íŠ¸ë¡¤ ì„¹ì…˜ ìŠ¤íƒ€ì¼ */
        .controls {
            margin-bottom: 25px;
            padding: 25px; 
            background-color: #fff5e6; 
            border-radius: 8px;
            border: 1px solid #f0e0c8;
        }
        .controls h3 {
            font-size: 1.6rem; 
            font-weight: normal;
            color: #6d4c41; 
            margin-bottom: 18px; 
        }
        .controls .input-group-text {
            background-color: #f5eadd;
            border-color: #e0d0b8;
            font-weight: normal; 
            color: #5d4037;
            font-size: 1rem; 
        }
        .controls .form-control, .controls .form-select {
            border-radius: 6px;
            border-color: #d7c6a9;
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif; 
            font-size: 1rem; 
        }
        .controls .form-control::placeholder {
            color: #9a8a7a;
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif;
        }
        .controls .btn-outline-secondary {
            border-color: #8d6e63; 
            color: #8d6e63;
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif;
        }
        .controls .btn-outline-secondary:hover {
            background-color: #8d6e63;
            color: white;
        }
        
        /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .btn {
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif; 
            font-weight: normal; 
            border-radius: 6px;
            padding: 10px 20px;
            font-size: 1.1rem; 
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.1s ease;
        }
        .btn:active {
            transform: translateY(1px);
        }
        .btn-primary {
            background-color: #795548; 
            border-color: #795548;
            color: #fff;
        }
        .btn-primary:hover {
            background-color: #5d4037;
            border-color: #5d4037;
            color: #fff;
        }
        .btn-info {
            background-color: #a1887f; 
            border-color: #a1887f;
            color: #fff;
        }
        .btn-info:hover {
            background-color: #8d6e63;
            border-color: #8d6e63;
            color: #fff;
        }
        .btn-success {
            background-color: #8bc34a; 
            border-color: #8bc34a;
            color: #fff;
        }
        .btn-success:hover {
            background-color: #7cb342;
            border-color: #7cb342;
            color: #fff;
        }

        /* ë¯¸ë¦¬ë³´ê¸° ì»¨í…Œì´ë„ˆ */
        .preview-container-wrapper { 
            border: 1px solid #e0d0b8;
            padding: 25px;
            margin-top: 0; 
            background-color: #fffdf9; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            border-radius: 0 0 8px 8px; 
        }
        .note-header {
            text-align: center;
            margin-bottom: 30px; 
            font-weight: normal; 
            font-size: 2.1rem; 
            color: #5d4037; 
        }

        /* ì„¹ì…˜ ìŠ¤íƒ€ì¼ */
        .section { 
            border: 1px solid #f0e0c8; 
            padding: 20px; 
            margin-bottom: 15px;
            border-radius: 8px; 
            background-color: #fffef7; 
            cursor: grab; 
            transition: box-shadow 0.2s ease-in-out;
        }
        .section:hover {
            box-shadow: 0 4px 10px rgba(0,0,0,0.06);
        }
        .section-title {
            font-weight: normal; 
            margin-bottom: 12px; 
            color: #795548; 
            font-size: 1.5em; 
            border-bottom: 2px solid #f5eadd;
            padding-bottom: 8px;
        }
        .section-title .emoji {
            margin-right: 8px;
        }

        .export-buttons-group {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #f0e0c8;
            display: flex;
            flex-wrap: wrap; 
            gap: 12px;
            justify-content: flex-end; 
        }
        
        /* ë¡œë”© ì¸ë””ì¼€ì´í„° */
        .loading {
            display: none;
            text-align: center;
            margin: 30px 0;
            font-size: 1.3rem; 
            color: #776b5d;
        }
        .loading-spinner {
            display: inline-block;
            width: 3rem; 
            height: 3rem; 
            border: 0.35rem solid #f5eadd; 
            border-top: 0.35rem solid #795548; 
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 15px; 
            vertical-align: middle;
        }
        /* íŒŒì¼ëª… í‘œì‹œ */
        #fileNameDisplay {
            margin-left: 10px;
            font-style: normal; 
            color: #776b5d;
            font-size: 1.05rem; 
        }
        /* ì¸ë¼ì¸ ë¼ë²¨ */
        .form-label-inline, label { 
            margin-bottom: 0;
            margin-right: 0.5rem;
            align-self: center;
            font-weight: normal; 
            font-size: 1.1rem; 
            color: #6d4c41;
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif;
        }
        /* ì‘ì€ í…ìŠ¤íŠ¸ (ì„¤ëª… ë“±) */
        small, .form-text {
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif;
            font-size: 1rem; 
            color: #8d6e63; 
        }
        
        /* íƒ­ ìŠ¤íƒ€ì¼ */
        .nav-tabs .nav-link {
            font-weight: normal; 
            color: #795548;
            border-radius: 6px 6px 0 0;
            padding: 10px 20px;
            font-size: 1.2rem; 
            border-bottom-width: 2px;
        }
        .nav-tabs .nav-link.active {
            color: #ffffff;
            background-color: #795548;
            border-color: #795548 #795548 #fffaf0;
        }
        .nav-tabs .nav-link:hover {
            border-color: #f0e0c8 #f0e0c8 #fff5e6;
            background-color: #fff5e6;
            color: #5d4037;
        }

        /* ì—ë””í„° í”Œë ˆì´ìŠ¤í™€ë” ë° ì½˜í…ì¸  ì˜ì—­ */
        .editor-content-placeholder { /* Quill ì—ë””í„°ê°€ ë  divì˜ ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
             min-height: 180px; 
             border: 1px solid #d7c6a9; 
             padding: 10px;
             border-radius: 6px;
             background-color: #fffdf9;
             font-family: 'Paperlogy', 'Noto Sans KR', sans-serif; 
             line-height: 1.75; 
             font-size: 1.05rem; 
        }
        /* Question 1, 2ëŠ” Quill ì—ë””í„°ê°€ ì•„ë‹˜ */
        #question1Content, #question2Content { 
             min-height: 180px; 
             border: 1px solid #d7c6a9; 
             padding: 10px;
             border-radius: 6px;
             background-color: #fffdf9;
             font-family: 'Paperlogy', 'Noto Sans KR', sans-serif; 
             line-height: 1.75; 
             font-size: 1.05rem; 
        }
         /* type2LiteralTranslationContent ì™€ literalTableContent ëŠ” Quill ì—ë””í„°ë¡œ ì´ˆê¸°í™”ë˜ë¯€ë¡œ, .editor-content-placeholder ìŠ¤íƒ€ì¼ì´ ì ìš©ë¨ */
        #type2LiteralTranslationContent.editor-content-placeholder,
        #literalTableContent.editor-content-placeholder {
            /* ì´ë¯¸ .editor-content-placeholderì— ì •ì˜ëœ ìŠ¤íƒ€ì¼ ì‚¬ìš© */
        }


        /* Quill ì—ë””í„° íˆ´ë°” ë° ì»¨í…Œì´ë„ˆ */
        .ql-toolbar.ql-snow {
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            border-bottom: 0px;
            background-color: #f5eadd;
            border-color: #d7c6a9;
        }
        .ql-container.ql-snow {
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
            border-color: #d7c6a9;
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif; 
        }
        .ql-editor {
            line-height: 1.75; 
            font-size: 1.05rem; 
            min-height: 180px; /* Quill ì—ë””í„° ìµœì†Œ ë†’ì´ ë³´ì¥ */
        }
        .ql-editor.ql-blank::before { 
            font-family: 'Paperlogy', 'Noto Sans KR', sans-serif;
            color: #9a8a7a;
            font-style: normal;
        }


        /* Quill Font Styles - Paperlogy ì¶”ê°€ */
        .ql-font-paperlogy { font-family: 'Paperlogy', sans-serif; } 
        .ql-font-arial { font-family: Arial, Helvetica, sans-serif; }
        .ql-font-comic-sans { font-family: "Comic Sans MS", cursive, sans-serif; }
        .ql-font-courier-new { font-family: "Courier New", Courier, monospace; }
        .ql-font-georgia { font-family: Georgia, serif; }
        .ql-font-helvetica { font-family: Helvetica, Arial, sans-serif; } 
        .ql-font-lucida-grande { font-family: "Lucida Sans Unicode", "Lucida Grande", Verdana, sans-serif; } 
        .ql-font-tahoma { font-family: Tahoma, Geneva, sans-serif; }
        .ql-font-times-new-roman { font-family: "Times New Roman", Times, serif; }
        .ql-font-trebuchet-ms { font-family: "Trebuchet MS", Helvetica, sans-serif; }
        .ql-font-verdana { font-family: Verdana, Geneva, sans-serif; }
        .ql-font-malgun-gothic { font-family: "Malgun Gothic", "ë§‘ì€ ê³ ë”•", Dotum, Gulim, AppleSDGothicNeo-Regular, sans-serif; }
        .ql-font-dotum { font-family: Dotum, "ë‹ì›€", Gulim, "êµ´ë¦¼", AppleGothic, sans-serif; }
        .ql-font-gulim { font-family: Gulim, "êµ´ë¦¼", Dotum, "ë‹ì›€", AppleGothic, sans-serif; }
        .ql-font-batang { font-family: Batang, "ë°”íƒ•", Gungsuh, "ê¶ì„œ", AppleMyungjo, serif; }
        .ql-font-gungsuh { font-family: Gungsuh, "ê¶ì„œ", Batang, "ë°”íƒ•", AppleMyungjo, serif; }
        .ql-font-my-custom-font { font-family: "My Custom Font", sans-serif; }

        /* Quill Picker Styles - Paperlogy ì¶”ê°€ */
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="paperlogy"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="paperlogy"]::before { content: "Paperlogy"; font-family: 'Paperlogy', sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="arial"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="arial"]::before { content: "Arial"; font-family: Arial, Helvetica, sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="comic-sans"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="comic-sans"]::before { content: "Comic Sans"; font-family: "Comic Sans MS", cursive, sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="courier-new"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="courier-new"]::before { content: "Courier New"; font-family: "Courier New", Courier, monospace; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="georgia"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="georgia"]::before { content: "Georgia"; font-family: Georgia, serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="helvetica"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="helvetica"]::before { content: "Helvetica"; font-family: Helvetica, Arial, sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="lucida-grande"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="lucida-grande"]::before { content: "Lucida Grande"; font-family: "Lucida Sans Unicode", "Lucida Grande", Verdana, sans-serif;}
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="tahoma"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="tahoma"]::before { content: "Tahoma"; font-family: Tahoma, Geneva, sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="times-new-roman"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="times-new-roman"]::before { content: "Times New Roman"; font-family: "Times New Roman", Times, serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="trebuchet-ms"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="trebuchet-ms"]::before { content: "Trebuchet MS"; font-family: "Trebuchet MS", Helvetica, sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="verdana"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="verdana"]::before { content: "Verdana"; font-family: Verdana, Geneva, sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="malgun-gothic"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="malgun-gothic"]::before { content: "ë§‘ì€ ê³ ë”•"; font-family: "Malgun Gothic", "ë§‘ì€ ê³ ë”•", sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="dotum"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="dotum"]::before { content: "ë‹ì›€"; font-family: Dotum, "ë‹ì›€", sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="gulim"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="gulim"]::before { content: "êµ´ë¦¼"; font-family: Gulim, "êµ´ë¦¼", sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="batang"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="batang"]::before { content: "ë°”íƒ•"; font-family: Batang, "ë°”íƒ•", serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="gungsuh"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="gungsuh"]::before { content: "ê¶ì„œ"; font-family: Gungsuh, "ê¶ì„œ", serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="my-custom-font"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="my-custom-font"]::before { content: "ë‚˜ì˜ í°íŠ¸"; font-family: "My Custom Font", sans-serif; }
        .ql-snow .ql-picker.ql-font .ql-picker-label::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item::before { content: attr(data-value); }
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="sans-serif"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="sans-serif"]::before { content: "Sans Serif"; font-family: sans-serif;}
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="serif"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="serif"]::before { content: "Serif"; font-family: serif;}
        .ql-snow .ql-picker.ql-font .ql-picker-label[data-value="monospace"]::before,
        .ql-snow .ql-picker.ql-font .ql-picker-item[data-value="monospace"]::before { content: "Monospace"; font-family: monospace;}

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @media print {
            .controls, button, .input-section, .api-section { display: none; }
            .preview-container-wrapper { border: none; box-shadow: none; }
            .nav-tabs { display: none; }
            .ql-toolbar { display: none !important; }
            .ql-container { border: none !important; }
            .ql-editor { padding: 0 !important; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="app-title">Gemini API ì˜ì–´ ìˆ˜ì—…ë…¸íŠ¸ ìƒì„±ê¸° <span class="emoji">âœï¸</span></h1>
        
        <div class="controls api-section">
            <h3><span class="emoji">ğŸ”‘</span> API ì„¤ì •</h3>
            <div class="input-group mb-3">
                <span class="input-group-text">Google Gemini API Key</span>
                <input type="text" id="apiKey" class="form-control" placeholder="ì—¬ê¸°ì— Gemini API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”">
                <button id="saveApiKey" class="btn btn-outline-secondary">ì €ì¥</button>
            </div>
            <div class="form-check mb-3">
                <input class="form-check-input" type="checkbox" id="rememberApiKey">
                <label class="form-check-label" for="rememberApiKey">
                    Gemini API í‚¤ ê¸°ì–µí•˜ê¸°
                </label>
            </div>
        </div>
            
        <div class="controls input-section">
            <h3><span class="emoji">ğŸ“¤</span> ì˜ì–´ ì§€ë¬¸ íŒŒì¼ ì—…ë¡œë“œ (TXT, DOCX)</h3>
            <div class="input-group">
                <input type="file" id="fileInput" class="form-control" accept=".txt,.docx,.pdf">
                <span id="fileNameDisplay" class="align-self-center"></span>
            </div>
             <small class="form-text text-muted">TXT ë˜ëŠ” DOCX íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”. PDF íŒŒì¼ì€ í˜„ì¬ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</small>
            
            <div class="row mt-3 align-items-center"> 
                <div class="col-lg col-md-6 mb-2 selector-group">
                    <label for="unitSelector" class="form-label-inline">UNIT:</label>
                    <select id="unitSelector" class="form-select" style="width: auto; flex-grow: 1;">
                        <option value="all">ì „ì²´ ì§€ë¬¸</option>
                    </select>
                </div>
                <div class="col-lg col-md-6 mb-2 selector-group">
                    <label for="sectionSelector" class="form-label-inline">ë¬¸ë‹¨:</label>
                    <select id="sectionSelector" class="form-select" style="width: auto; flex-grow: 1;">
                        <option value="unit_full_content">UNIT ì „ì²´ ë‚´ìš©</option>
                    </select>
                </div>
                <div class="col-lg col-md-6 mb-2 selector-group">
                    <label for="paragraphSelector" class="form-label-inline">ë‹¨ë½:</label>
                    <select id="paragraphSelector" class="form-select" style="width: auto; flex-grow: 1;">
                        <option value="section_full_content">ë¬¸ë‹¨ ì „ì²´ ë³´ê¸°</option>
                    </select>
                </div>
            </div>
            <div class="row mt-3"> 
                 <div class="col-md-12">
                    <button id="generateButton" class="btn btn-primary btn-lg w-100"><span class="emoji">ğŸ’¡</span> ìˆ˜ì—…ë…¸íŠ¸ ìƒì„± ë° í¸ì§‘ê¸° ë¡œë“œ</button>
                </div>
            </div>
        </div>
        
        <div class="loading">
            <div class="loading-spinner"></div>
            <span>AIê°€ ìˆ˜ì—…ë…¸íŠ¸ë¥¼ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤... ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.</span>
        </div>

        <ul class="nav nav-tabs mt-4" id="noteTypeTab" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="type1-tab" data-bs-toggle="tab" data-bs-target="#type1-content" type="button" role="tab" aria-controls="type1-content" aria-selected="true"><span class="emoji">ğŸ‡¬ğŸ‡§</span> 1ì¢…: ì˜ì–´ ì§€ë¬¸ë§Œ</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="type2-tab" data-bs-toggle="tab" data-bs-target="#type2-content" type="button" role="tab" aria-controls="type2-content" aria-selected="false"><span class="emoji">ğŸ“–</span> 2ì¢…: í•œì¤„ í•´ì„</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="type3-tab" data-bs-toggle="tab" data-bs-target="#type3-content" type="button" role="tab" aria-controls="type3-content" aria-selected="false"><span class="emoji">ğŸ“š</span> 3ì¢…: ì „ì²´ êµ¬ì„±</button>
            </li>
        </ul>

        <div class="tab-content" id="noteTypeTabContent">
            <div class="tab-pane fade show active" id="type1-content" role="tabpanel" aria-labelledby="type1-tab">
                <div class="preview-container-wrapper">
                    <div class="note-header">ìˆ˜ì—… ë…¸íŠ¸ (1ì¢…: ì˜ì–´ ì§€ë¬¸ë§Œ)</div>
                    <div class="section">
                        <div class="section-title"><span class="emoji">ğŸ‡¬ğŸ‡§</span> ì˜ì–´ ì§€ë¬¸</div>
                        <div class="content editor-content-placeholder" id="type1EnglishPassageContent"></div>
                    </div>
                    <div class="export-buttons-group">
                        <button id="exportGoogleDocsType1" class="btn btn-info"><span class="emoji">ğŸ“„</span> Google Docs</button>
                        <button id="exportButtonType1" class="btn btn-success"><span class="emoji">ğŸ’¾</span> MS-WORD</button>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="type2-content" role="tabpanel" aria-labelledby="type2-tab">
                 <div class="preview-container-wrapper">
                    <div class="note-header">ìˆ˜ì—… ë…¸íŠ¸ (2ì¢…: í•œì¤„ í•´ì„)</div>
                    <div class="section">
                        <div class="section-title"><span class="emoji">ğŸ—£ï¸</span> í•œì¤„ í•´ì„ (ì˜ì–´ ì›ë¬¸ + ì§ì—­)</div>
                        <div class="content editor-content-placeholder" id="type2LiteralTranslationContent"> 
                            <p class="text-muted">ìˆ˜ì—…ë…¸íŠ¸ ìƒì„± í›„ ì—¬ê¸°ì— í•œì¤„ í•´ì„ ë‚´ìš©ì´ í‘œì‹œë©ë‹ˆë‹¤.</p>
                        </div>
                    </div>
                    <div class="export-buttons-group">
                        <button id="exportGoogleDocsType2" class="btn btn-info"><span class="emoji">ğŸ“„</span> Google Docs</button>
                        <button id="exportButtonType2" class="btn btn-success"><span class="emoji">ğŸ’¾</span> MS-WORD</button>
                    </div>
                </div>
            </div>
            
            <div class="tab-pane fade" id="type3-content" role="tabpanel" aria-labelledby="type3-tab">
                <div class="preview-container-wrapper">
                    <div class="note-header">ìˆ˜ì—… ë…¸íŠ¸ (ì „ì²´ êµ¬ì„±)</div>
                    <div class="row">
                        <div class="col-md-6 column-left draggable-container">
                            <div class="section" id="englishPassageSection" draggable="true">
                                <div class="section-title"><span class="emoji">ğŸ‡¬ğŸ‡§</span> ì˜ì–´ ì§€ë¬¸ (ì„ íƒëœ ë‚´ìš©)</div>
                                <div class="content editor-content-placeholder" id="englishPassageContent"></div>
                            </div>
                            <div class="section" id="koreanInterpretationSection" draggable="true">
                                <div class="section-title"><span class="emoji">ğŸ‡°ğŸ‡·</span> í•œêµ­ì–´ ì˜ì—­</div>
                                <div class="content editor-content-placeholder" id="koreanInterpretationContent"></div>
                            </div>
                        </div>
                        <div class="col-md-6 column-right draggable-container">
                            <div class="section" id="topicEnglishSection" draggable="true">
                                <div class="section-title"><span class="emoji">ğŸ’¡</span> ì£¼ì œ (ì˜ì–´)</div>
                                <div class="content editor-content-placeholder" id="topicEnglishContent"></div>
                            </div>
                            <div class="section" id="topicKoreanSection" draggable="true">
                                <div class="section-title"><span class="emoji">ğŸ’¡</span> ì£¼ì œ (í•œêµ­ì–´)</div>
                                <div class="content editor-content-placeholder" id="topicKoreanContent"></div>
                            </div>
                            <div class="section" id="question1Section" draggable="true">
                                <div class="section-title"><span class="emoji">â“</span> Question 1</div>
                                <div class="content" id="question1Content"></div>
                            </div>
                            <div class="section" id="question2Section" draggable="true">
                                <div class="section-title"><span class="emoji">â“</span> Question 2</div>
                                <div class="content" id="question2Content"></div>
                            </div>
                        </div>
                    </div>
                    <div class="section full-width-section draggable-container" id="literalTableFullSection" draggable="true">
                        <div class="section-title"><span class="emoji">ğŸ—£ï¸</span> ì§ì—­ (Literal Translation)</div>
                        <div class="content editor-content-placeholder" id="literalTableContent"></div> 
                    </div>
                    <div class="section full-width-section draggable-container" id="englishOnlyFullSection" draggable="true">
                        <div class="section-title"><span class="emoji">ğŸ‡¬ğŸ‡§</span> ì˜ì–´ ì§€ë¬¸ë§Œ (ì„ íƒëœ ë‚´ìš©)</div>
                        <div class="content editor-content-placeholder" id="englishOnlyContent"></div>
                    </div>
                    <div class="export-buttons-group">
                        <button id="exportGoogleDocsType3" class="btn btn-info"><span class="emoji">ğŸ“„</span> Google Docs</button>
                        <button id="exportButtonType3" class="btn btn-success"><span class="emoji">ğŸ’¾</span> MS-WORD</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
    // ì „ì—­ ë³€ìˆ˜
    window.uploadedEnglishText = ""; 
    let parsedUnits = []; 
    const GRAMMAR_TITLE_REGEX = /^\s*GRAMMAR\s+for\s+Reading\s*$/i; 
    const READING_TITLE_REGEX = /^\s*ìˆ˜ëŠ¥\s+ìœ í˜•\s+ë…í•´\s*$/i; 
    const PARAGRAPH_MARKER_REGEX = /^\s*(ëª¨ì˜ê³ ì‚¬\s+ê¸°ì¶œ|ê¸°ì¶œ\s*Preview|(\d+))\s*\.?\s*/i; 
    const SUNEUNG_GICHO_REGEX = /^\s*ìˆ˜ëŠ¥\s+ê¸°ì´ˆ/i; 
    let activeQuillEditors = {}; 
    
    const ALL_QUILL_EDITOR_IDS = [
        'type1EnglishPassageContent',
        'type2LiteralTranslationContent', 
        'englishPassageContent',
        'koreanInterpretationContent',
        'topicEnglishContent',
        'topicKoreanContent',
        'literalTableContent',         
        'englishOnlyContent'
    ];
    const NON_QUILL_CONTENT_IDS = ['question1Content', 'question2Content'];
    const EDITOR_ID_TYPE1 = 'type1EnglishPassageContent'; // ëª…ì‹œì ìœ¼ë¡œ ìœ ì§€ (ê°€ë…ì„± ë° í˜¹ì‹œ ëª¨ë¥¼ ì°¸ì¡° ëŒ€ë¹„)


    const QUILL_FONT_WHITELIST = [
        'paperlogy', 
        'sans-serif', 'serif', 'monospace', 
        'arial', 'comic-sans', 'courier-new', 'georgia', 'helvetica', 'lucida-grande', 'tahoma', 'times-new-roman', 'trebuchet-ms', 'verdana',
        'malgun-gothic', 'dotum', 'gulim', 'batang', 'gungsuh',
        'my-custom-font' 
    ];

    function registerQuillFonts() {
        if (typeof Quill !== 'undefined') {
            let Font = Quill.import('formats/font');
            Font.whitelist = QUILL_FONT_WHITELIST; 
            Quill.register(Font, true);
            console.log("Quill Fonts registered globally with whitelist:", Font.whitelist);
        } else {
            console.error("Quill is not loaded when trying to register fonts globally. Will try again on DOMContentLoaded.");
        }
    }
    if (typeof Quill !== 'undefined') {
        registerQuillFonts();
    }


    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM fully loaded. Quill object:", typeof Quill); 
        if (typeof Quill !== 'undefined' && Quill.import('formats/font') && !(Quill.import('formats/font')).whitelist.includes('paperlogy')) {
            registerQuillFonts();
        }

        const generateButton = document.getElementById('generateButton');
        const apiKeyInput = document.getElementById('apiKey');
        const saveApiKeyButton = document.getElementById('saveApiKey');
        const rememberApiKeyCheckbox = document.getElementById('rememberApiKey');
        
        const loadingElement = document.querySelector('.loading');
        const fileInput = document.getElementById('fileInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const unitSelector = document.getElementById('unitSelector');
        const sectionSelector = document.getElementById('sectionSelector');
        const paragraphSelector = document.getElementById('paragraphSelector');
        
        if (localStorage.getItem('geminiApiKey')) {
            apiKeyInput.value = localStorage.getItem('geminiApiKey');
            rememberApiKeyCheckbox.checked = true;
        }
        saveApiKeyButton.addEventListener('click', function() {
            const apiKey = apiKeyInput.value.trim();
            if (apiKey) {
                if (rememberApiKeyCheckbox.checked) { localStorage.setItem('geminiApiKey', apiKey); } 
                else { localStorage.removeItem('geminiApiKey'); }
                alert('Gemini API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else { alert('Gemini API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.'); }
        });
        
        function initQuillEditor(elementId, initialContent = '') {
            const targetElement = document.getElementById(elementId);
            if (!targetElement) {
                console.error(`Quill target element with ID '${elementId}' not found.`);
                return;
            }
            if (NON_QUILL_CONTENT_IDS.includes(elementId)) {
                console.log(`Skipping Quill initialization for non-Quill element ${elementId}, using innerHTML directly.`);
                targetElement.innerHTML = initialContent;
                targetElement.classList.remove('editor-content-placeholder');
                return;
            }

            if (typeof Quill === 'undefined') {
                console.error('Quill.js is not loaded. Cannot initialize editor for:', elementId);
                targetElement.innerHTML = initialContent || '<p>í¸ì§‘ê¸°ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            if (activeQuillEditors[elementId] && typeof activeQuillEditors[elementId].destroy === 'function') {
                console.log(`Destroying existing Quill instance for ${elementId} before re-initializing.`);
                try {
                    activeQuillEditors[elementId].destroy();
                } catch (e) {
                    console.error(`Error destroying Quill for ${elementId}:`, e);
                }
                delete activeQuillEditors[elementId];
            }

            const previousToolbar = targetElement.previousElementSibling;
            if (previousToolbar && previousToolbar.classList.contains('ql-toolbar')) {
                previousToolbar.remove();
            }
            targetElement.classList.remove('ql-container', 'ql-snow');
            while (targetElement.firstChild) {
                targetElement.removeChild(targetElement.firstChild);
            }
            targetElement.classList.remove('editor-content-placeholder'); 

            const quill = new Quill(targetElement, {
                modules: {
                    toolbar: [ 
                        [{ 'font': QUILL_FONT_WHITELIST }, { 'size': ['small', false, 'large', 'huge'] }], 
                        ['bold', 'italic', 'underline', 'strike'],        
                        [{ 'color': [] }, { 'background': [] }],          
                        [{ 'header': 1 }, { 'header': 2 }, 'blockquote', 'code-block'], 
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }, { 'indent': '-1'}, { 'indent': '+1' }], 
                        [{ 'script': 'sub'}, { 'script': 'super' }],      
                        [{ 'align': [] }],                                 
                        ['link', 'image', 'video'],                       
                        ['clean']                                         
                    ]
                },
                placeholder: 'ì—¬ê¸°ì— ë‚´ìš©ì„ ì…ë ¥í•˜ê±°ë‚˜ ìƒì„±ëœ ì½˜í…ì¸ ê°€ í‘œì‹œë©ë‹ˆë‹¤...',
                theme: 'snow' 
            });
            if (initialContent) { 
                 quill.root.innerHTML = initialContent; 
            }
            activeQuillEditors[elementId] = quill; 
            console.log(`Quill editor initialized for ${elementId}`);
        }

        async function destroyQuillEditors() {
            console.log("Attempting to destroy all Quill editors and clear content divs. Current active editors:", Object.keys(activeQuillEditors));
            
            const allEditableDivIds = [...ALL_QUILL_EDITOR_IDS, ...NON_QUILL_CONTENT_IDS];

            for (const editorId of allEditableDivIds) {
                const editorDiv = document.getElementById(editorId);
                if (!editorDiv) continue;

                if (ALL_QUILL_EDITOR_IDS.includes(editorId) && activeQuillEditors[editorId] && typeof activeQuillEditors[editorId].destroy === 'function') {
                    try {
                        console.log(`Destroying Quill editor for ${editorId}`);
                        await activeQuillEditors[editorId].destroy();
                        console.log(`Quill editor for ${editorId} destroyed.`);
                    } catch (error) {
                        console.error(`Error destroying Quill editor for ${editorId}:`, error);
                    }
                }
                
                const toolbar = editorDiv.previousElementSibling;
                if (toolbar && toolbar.classList.contains('ql-toolbar')) {
                    toolbar.remove();
                }
                editorDiv.innerHTML = ''; 
                editorDiv.classList.remove('ql-container', 'ql-snow'); 
                
                if (ALL_QUILL_EDITOR_IDS.includes(editorId)) {
                    editorDiv.classList.add('editor-content-placeholder');
                }
            }
            activeQuillEditors = {};
            console.log("All Quill editors presumably destroyed and content divs cleared.");
        }
        
        function parseSectionParagraphs(sectionFullText, sectionTypePrefix) {
            const paragraphs = [];
            if (!sectionFullText) return paragraphs;

            const lines = sectionFullText.split('\n');
            let currentParagraphContentBuffer = [];
            let paragraphIndex = 0;
            let isInsideParagraph = false;
            let currentOriginalMarkerLine = null; 

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const lineTrimmed = line.trim();
                const isSuneungGichoStart = SUNEUNG_GICHO_REGEX.test(lineTrimmed);
                const isStandardParaStart = PARAGRAPH_MARKER_REGEX.test(lineTrimmed);
                const isParagraphStartMarker = isSuneungGichoStart || isStandardParaStart;

                if (isParagraphStartMarker) { 
                    if (isInsideParagraph && currentParagraphContentBuffer.length > 0) { 
                        const fullParaText = currentParagraphContentBuffer.join('\n').trim();
                        if (fullParaText) {
                            paragraphs.push({
                                id: `${sectionTypePrefix}_p${paragraphIndex++}`,
                                originalMarkerLine: currentOriginalMarkerLine, 
                                text: fullParaText
                            });
                        }
                    }
                    currentParagraphContentBuffer = [line]; 
                    currentOriginalMarkerLine = lineTrimmed; 
                    isInsideParagraph = true;
                } else if (isInsideParagraph) { 
                    currentParagraphContentBuffer.push(line);
                } else if (i === 0 && lineTrimmed && !isParagraphStartMarker && sectionTypePrefix === 'g') { 
                    currentParagraphContentBuffer = [line];
                    currentOriginalMarkerLine = lineTrimmed; 
                    isInsideParagraph = true;
                }
            }

            if (isInsideParagraph && currentParagraphContentBuffer.length > 0) {
                const fullParaText = currentParagraphContentBuffer.join('\n').trim();
                if (fullParaText) {
                    paragraphs.push({
                        id: `${sectionTypePrefix}_p${paragraphIndex++}`,
                        originalMarkerLine: currentOriginalMarkerLine,
                        text: fullParaText
                    });
                }
            }
            
            if (paragraphs.length === 0 && sectionFullText.trim() && sectionTypePrefix === 'g') {
                const linesOfSection = sectionFullText.split('\n');
                const contentStartIndex = GRAMMAR_TITLE_REGEX.test(linesOfSection[0].trim()) ? 1 : 0; 
                const actualContent = linesOfSection.slice(contentStartIndex).join('\n').trim();
                if(actualContent) {
                    paragraphs.push({
                        id: `${sectionTypePrefix}_p_full`,
                        originalMarkerLine: linesOfSection[contentStartIndex] ? linesOfSection[contentStartIndex].trim() : "ë¬¸ë²• ì„¤ëª…", 
                        text: actualContent
                    });
                }
            }
            return paragraphs;
        }

        async function parseAndPopulateUnitsAndSections(fullText) { 
            await destroyQuillEditors(); 
            while (unitSelector.options.length > 1) { unitSelector.remove(1); }
            sectionSelector.innerHTML = '<option value="unit_full_content">UNIT ì „ì²´ ë‚´ìš©</option>';
            paragraphSelector.innerHTML = '<option value="section_full_content">ë¬¸ë‹¨ ì „ì²´ ë³´ê¸°</option>';

            parsedUnits = []; 
            
            ALL_QUILL_EDITOR_IDS.forEach(id => {
                const el = document.getElementById(id);
                if(el) {
                    el.innerHTML = ''; 
                    el.classList.add('editor-content-placeholder');
                }
            });
            NON_QUILL_CONTENT_IDS.forEach(id => {
                const el = document.getElementById(id);
                if(el) el.innerHTML = '';
            });

            const type2ContentEl = document.getElementById('type2LiteralTranslationContent');
            if (type2ContentEl) { 
                type2ContentEl.innerHTML = '<p class="text-muted">ìˆ˜ì—…ë…¸íŠ¸ ìƒì„± í›„ ì—¬ê¸°ì— í•œì¤„ í•´ì„ ë‚´ìš©ì´ í‘œì‹œë©ë‹ˆë‹¤.</p>';
                if (!type2ContentEl.classList.contains('editor-content-placeholder')) {
                    type2ContentEl.classList.add('editor-content-placeholder');
                }
            }


            let currentUnitObject = null;
            let collectingForSectionType = null; 
            let currentSectionContentBuffer = []; 
            const lines = fullText.split('\n');

            const finalizeCollectedSection = (unitObj, sectionType, buffer) => {
                if (unitObj && sectionType && buffer.length > 0) {
                    const fullSectionTextWithTitle = buffer.join('\n').trim(); 
                    if (fullSectionTextWithTitle) {
                        const sectionTitle = buffer[0].trim(); 
                        const paragraphs = parseSectionParagraphs(fullSectionTextWithTitle, sectionType.charAt(0)); 
                        
                        if (sectionType === 'grammar') {
                            unitObj.grammarSection = { title: sectionTitle, fullText: fullSectionTextWithTitle, paragraphs: paragraphs };
                        } else if (sectionType === 'reading') {
                            unitObj.readingSection = { title: sectionTitle, fullText: fullSectionTextWithTitle, paragraphs: paragraphs };
                        }
                    }
                }
                currentSectionContentBuffer = []; 
            };
            
            lines.forEach((line) => {
                const unitHeaderMatch = line.match(/^UNIT\s+(\d+.*)/i); 
                
                if (unitHeaderMatch) { 
                    if (currentUnitObject) { 
                        finalizeCollectedSection(currentUnitObject, collectingForSectionType, currentSectionContentBuffer);
                        currentUnitObject.unitContentWithoutTitle = currentUnitObject.unitContentWithoutTitle.join('\n').trim();
                        parsedUnits.push(currentUnitObject);
                    }
                    currentUnitObject = {
                        unitTitle: `UNIT ${unitHeaderMatch[1].trim()}`,
                        unitContentWithoutTitle: [], 
                        grammarSection: null, 
                        readingSection: null,
                    };
                    unitSelector.add(new Option(currentUnitObject.unitTitle, currentUnitObject.unitTitle)); 
                    collectingForSectionType = null; 
                } else if (currentUnitObject) { 
                    currentUnitObject.unitContentWithoutTitle.push(line); 

                    if (GRAMMAR_TITLE_REGEX.test(line.trim())) { 
                        finalizeCollectedSection(currentUnitObject, collectingForSectionType, currentSectionContentBuffer); 
                        collectingForSectionType = 'grammar';
                        currentSectionContentBuffer.push(line); 
                    } else if (READING_TITLE_REGEX.test(line.trim())) { 
                        finalizeCollectedSection(currentUnitObject, collectingForSectionType, currentSectionContentBuffer); 
                        collectingForSectionType = 'reading';
                        currentSectionContentBuffer.push(line); 
                    } else if (collectingForSectionType) { 
                        currentSectionContentBuffer.push(line);
                    }
                }
            });

            if (currentUnitObject) {
                finalizeCollectedSection(currentUnitObject, collectingForSectionType, currentSectionContentBuffer);
                currentUnitObject.unitContentWithoutTitle = currentUnitObject.unitContentWithoutTitle.join('\n').trim();
                parsedUnits.push(currentUnitObject);
            }
            
            if (parsedUnits.length > 0) {
                unitSelector.value = parsedUnits[0].unitTitle; 
                await updateSectionSelector(); 
            } else { 
                unitSelector.value = "all";
                sectionSelector.disabled = true;
                paragraphSelector.disabled = true;
                if (fullText.trim() !== "") { 
                     const initialContent = fullText.replace(/\n/g, '<br>');
                     initQuillEditor('englishPassageContent', initialContent); 
                     initQuillEditor(EDITOR_ID_TYPE1, initialContent);      
                }
            }
        }
        
        async function updateSectionSelector() { 
            const selectedUnitTitle = unitSelector.value;
            sectionSelector.innerHTML = '<option value="unit_full_content">UNIT ì „ì²´ ë‚´ìš©</option>';
            paragraphSelector.innerHTML = '<option value="section_full_content">ë¬¸ë‹¨ ì „ì²´ ë³´ê¸°</option>';
            sectionSelector.disabled = true;
            paragraphSelector.disabled = true;

            if (selectedUnitTitle === "all") { 
                await displaySelectedContent(); 
                return;
            }

            const selectedUnit = parsedUnits.find(unit => unit.unitTitle === selectedUnitTitle);
            if (selectedUnit) {
                sectionSelector.disabled = false;
                if (selectedUnit.grammarSection) {
                    sectionSelector.add(new Option(selectedUnit.grammarSection.title, "grammar"));
                }
                if (selectedUnit.readingSection) {
                    sectionSelector.add(new Option(selectedUnit.readingSection.title, "reading"));
                }
                await updateParagraphSelector(); 
            }
        }

        async function updateParagraphSelector() { 
            const unitChoice = unitSelector.value;
            const sectionChoice = sectionSelector.value;
            paragraphSelector.innerHTML = '<option value="section_full_content">ë¬¸ë‹¨ ì „ì²´ ë³´ê¸°</option>';
            paragraphSelector.disabled = true;

            if (unitChoice === "all" || sectionChoice === "unit_full_content") { 
                await displaySelectedContent();
                return;
            }

            const selectedUnit = parsedUnits.find(unit => unit.unitTitle === unitChoice);
            if (selectedUnit) {
                let sectionData = null;
                if (sectionChoice === "grammar" && selectedUnit.grammarSection) {
                    sectionData = selectedUnit.grammarSection;
                } else if (sectionChoice === "reading" && selectedUnit.readingSection) {
                    sectionData = selectedUnit.readingSection;
                }

                if (sectionData && sectionData.paragraphs && sectionData.paragraphs.length > 0) {
                    paragraphSelector.disabled = false;
                    sectionData.paragraphs.forEach(para => {
                        let optionText = "";
                        const unitNumberMatch = unitChoice.match(/^UNIT\s*0*(\d+)/i);
                        const currentUnitNumberStr = unitNumberMatch ? unitNumberMatch[1] : null;
                        const isSpecialUnitForSuneungGicho = currentUnitNumberStr && ["2", "8", "10"].includes(currentUnitNumberStr);
                        
                        if (isSpecialUnitForSuneungGicho && sectionChoice === "reading" && para.originalMarkerLine && SUNEUNG_GICHO_REGEX.test(para.originalMarkerLine.trim())) {
                            optionText = "ìˆ˜ëŠ¥ ê¸°ì´ˆ";
                        } else {
                            const markerMatch = para.originalMarkerLine ? para.originalMarkerLine.match(PARAGRAPH_MARKER_REGEX) : null;
                            if (markerMatch) { 
                                if (markerMatch[2]) { 
                                    optionText = `ë¬¸ì œ ${markerMatch[2].trim()}`;
                                } else if (markerMatch[1].toLowerCase().includes("ëª¨ì˜ê³ ì‚¬")) {
                                    optionText = "ëª¨ì˜ê³ ì‚¬ ê¸°ì¶œ";
                                } else if (markerMatch[1].toLowerCase().includes("ê¸°ì¶œ preview")) {
                                    optionText = "ê¸°ì¶œ Preview";
                                } else { 
                                    const contentAfterMarker = para.text.substring(para.originalMarkerLine.length).trim();
                                    optionText = (contentAfterMarker.substring(0, 30) + (contentAfterMarker.length > 30 ? "..." : "")).replace(/\n/g, ' ');
                                }
                            } else { 
                                const contentPreview = (para.originalMarkerLine || para.text)
                                                    .replace(GRAMMAR_TITLE_REGEX, '') 
                                                    .replace(READING_TITLE_REGEX, '') 
                                                    .trim().replace(/\n/g, ' ').substring(0,30);
                                optionText = (contentPreview + ((para.originalMarkerLine || para.text).length > 30 ? "..." : ""));
                            }
                        }
                        
                        if (!optionText && para.text) { 
                             const contentPreview = para.text.replace(/\n/g, ' ').substring(0,30);
                             optionText = (contentPreview + (para.text.length > 30 ? "..." : ""));
                        }
                        if (!optionText.trim()) optionText = `í•­ëª© ${para.id.slice(-2)}`; 

                        paragraphSelector.add(new Option(optionText.trim() || "ë‚´ìš© ë³´ê¸°", para.id));
                    });
                }
            }
            await displaySelectedContent(); 
        }

        async function displaySelectedContent() { 
            const unitChoice = unitSelector.value;
            const sectionChoice = sectionSelector.value;
            const paragraphChoice = paragraphSelector.value;
            let displayText = "";
            
            if (unitChoice === "all") {
                displayText = window.uploadedEnglishText;
            } else {
                const selectedUnit = parsedUnits.find(unit => unit.unitTitle === unitChoice);
                if (selectedUnit) {
                    if (sectionChoice === "unit_full_content") {
                        displayText = selectedUnit.unitTitle + "\n" + selectedUnit.unitContentWithoutTitle;
                    } else {
                        let targetSection = null;
                        if (sectionChoice === "grammar" && selectedUnit.grammarSection) {
                            targetSection = selectedUnit.grammarSection;
                        } else if (sectionChoice === "reading" && selectedUnit.readingSection) {
                            targetSection = selectedUnit.readingSection;
                        }

                        if (targetSection) {
                            if (paragraphChoice === "section_full_content" || !targetSection.paragraphs || targetSection.paragraphs.length === 0) {
                                displayText = targetSection.fullText; 
                            } else {
                                const selectedPara = targetSection.paragraphs.find(p => p.id === paragraphChoice);
                                displayText = selectedPara ? selectedPara.text : targetSection.fullText; 
                            }
                        } else { 
                             displayText = selectedUnit.unitTitle + "\n" + selectedUnit.unitContentWithoutTitle;
                        }
                    }
                } else {
                    displayText = "ì„ íƒëœ ìœ ë‹›ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
                }
            }
            
            const formattedDisplayText = displayText.replace(/\n/g, '<br>'); 

            initQuillEditor('englishPassageContent', formattedDisplayText);
            initQuillEditor(EDITOR_ID_TYPE1, formattedDisplayText); 
        }

        fileInput.addEventListener('change', async function(event) { 
            const file = event.target.files[0];
            if (!file) { 
                fileNameDisplay.textContent = ""; window.uploadedEnglishText = "";
                await parseAndPopulateUnitsAndSections(""); 
                return;
            }
            fileNameDisplay.textContent = `ì„ íƒëœ íŒŒì¼: ${file.name}`;
            const reader = new FileReader();
            const processTextFile = async (text) => { 
                window.uploadedEnglishText = text;
                await parseAndPopulateUnitsAndSections(text);
            };

            if (file.name.endsWith('.txt')) { 
                reader.onload = async (e) => await processTextFile(e.target.result); 
                reader.readAsText(file);
            } else if (file.name.endsWith('.docx')) { 
                reader.onload = (e) => {
                    mammoth.extractRawText({ arrayBuffer: e.target.result })
                        .then(async result => await processTextFile(result.value)) 
                        .catch(async err => { 
                            console.error("Error extracting DOCX:", err); 
                            alert('DOCX íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. íŒŒì¼ í˜•ì‹ì´ ì˜¬ë°”ë¥´ê±°ë‚˜ ì†ìƒë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”. ë˜ëŠ” ë‹¤ë¥¸ íŒŒì¼ë¡œ ì‹œë„í•´ë³´ì„¸ìš”. (ì½˜ì†”ì—ì„œ ìì„¸í•œ ì˜¤ë¥˜ í™•ì¸ ê°€ëŠ¥)');
                            fileNameDisplay.textContent = ""; window.uploadedEnglishText = "";
                            await parseAndPopulateUnitsAndSections(""); fileInput.value = null; 
                        });
                };
                reader.readAsArrayBuffer(file);
            } else { 
                alert(file.name.endsWith('.pdf') ? 'PDF íŒŒì¼ ì²˜ë¦¬ëŠ” í˜„ì¬ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' : 'ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. TXT ë˜ëŠ” DOCX íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.');
                fileNameDisplay.textContent = ""; window.uploadedEnglishText = "";
                await parseAndPopulateUnitsAndSections(""); fileInput.value = null; 
            }
        });

        unitSelector.addEventListener('change', updateSectionSelector);
        sectionSelector.addEventListener('change', updateParagraphSelector);
        paragraphSelector.addEventListener('change', displaySelectedContent);
        
        
        generateButton.addEventListener('click', async function() { 
            const apiKeyVal = apiKeyInput.value.trim();
            const textForAPI = getCurrentTextForExport(); 
            
            if (!textForAPI || !textForAPI.trim()) {
                alert('ì˜ì–´ ì§€ë¬¸ì´ í¬í•¨ëœ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê³  UNIT/ë¬¸ë‹¨/ë‹¨ë½ì„ ì„ íƒí•´ì£¼ì„¸ìš”.'); return;
            }
            if (!apiKeyVal) {
                alert('Google Gemini API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.'); return;
            }
            
            loadingElement.style.display = 'block'; 
            await destroyQuillEditors(); 

            const formattedTextForAPI = textForAPI.replace(/\n/g, '<br>');
            initQuillEditor('englishPassageContent', formattedTextForAPI); 
            initQuillEditor(EDITOR_ID_TYPE1, formattedTextForAPI); 
            
            ALL_QUILL_EDITOR_IDS.forEach(id => {
                if (id !== 'englishPassageContent' && id !== EDITOR_ID_TYPE1) { 
                    const el = document.getElementById(id);
                    if (el) {
                         initQuillEditor(id, '<p>ìƒì„± ì¤‘...</p>'); 
                    }
                }
            });

            NON_QUILL_CONTENT_IDS.forEach(id => {
                 document.getElementById(id).innerHTML = '<p class="text-muted">ìƒì„± ì¤‘...</p>';
            });
            
            await generateAllContent(textForAPI, apiKeyVal); 
        });
        
        async function generateAllContent(englishText, apiKeyVal) { 
            try {
                const [
                    koreanInterpretation, topicData, question1, question2, literalTranslation
                ] = await Promise.all([
                    generateKoreanInterpretation(englishText, apiKeyVal),
                    generateTopics(englishText, apiKeyVal),
                    generateQuestion1(englishText, apiKeyVal),
                    generateQuestion2(englishText, apiKeyVal),
                    generateLiteralTranslation(englishText, apiKeyVal)
                ]);
                
                // Helper function to format literal translation for Quill
                function formatLiteralTranslationForQuill(htmlString) {
                    if (!htmlString) return '<p class="text-muted">ì§ì—­ ì •ë³´ë¥¼ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>';
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlString; // API ì‘ë‹µ: <p><b>Eng1</b><br>Kor1</p><p><b>Eng2</b><br>Kor2</p>
                    let quillHtml = '';
                    const paragraphs = tempDiv.querySelectorAll('p');
                    paragraphs.forEach(p => {
                        const boldNode = p.querySelector('b');
                        if (boldNode) {
                            const engText = boldNode.textContent.trim();
                            let korText = "";
                            
                            // Extract Korean text (text after <br>)
                            const innerHTMLParts = p.innerHTML.split(/<br\s*\/?>/i);
                            if (innerHTMLParts.length > 1) {
                                const tempKorDiv = document.createElement('div');
                                // Join remaining parts in case Korean text itself contains <br> (though unlikely for this API)
                                tempKorDiv.innerHTML = innerHTMLParts.slice(1).join('<br>'); 
                                korText = tempKorDiv.textContent.trim();
                            } else { 
                                // Fallback if no <br> or structure is unexpected after removing <b>
                                let tempFullText = p.textContent.trim();
                                if (tempFullText.startsWith(engText)) {
                                    korText = tempFullText.substring(engText.length).trim();
                                } else {
                                     // If engText is not at the start, it's harder to reliably get korText this way
                                     // This case should be rare given the API's specified output format
                                    korText = tempFullText; 
                                }
                            }
                            // Ensure empty strings are handled to avoid "null" or "undefined" in output
                            if (engText) quillHtml += `<p>${engText}</p>`;
                            // Add an empty paragraph for Korean if it's empty but English exists, to maintain pairing for editing
                            quillHtml += `<p>${korText || ' '}</p>`; // Use a space if korText is empty to create an editable line
                        } else if (p.textContent.trim()) { 
                            quillHtml += `<p>${p.textContent.trim()}</p>`;
                        }
                    });
                    return quillHtml || '<p class="text-muted">ì§ì—­ ì •ë³´ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>';
                }

                const formattedLiteralTranslation = formatLiteralTranslationForQuill(literalTranslation);

                const quillEditorContents = {
                    'koreanInterpretationContent': koreanInterpretation.replace(/```html|```/g, '').trim(),
                    'topicEnglishContent': topicData.english.replace(/```html|```/g, '').trim(),
                    'topicKoreanContent': topicData.korean.replace(/```html|```/g, '').trim(),
                    'literalTableContent': formattedLiteralTranslation, 
                    'englishOnlyContent': englishText.replace(/\n/g, '<br>'),
                    'type2LiteralTranslationContent': formattedLiteralTranslation 
                };

                for (const id in quillEditorContents) {
                    if (id === 'englishPassageContent' || id === EDITOR_ID_TYPE1) continue; 

                    if (activeQuillEditors[id]) {
                        activeQuillEditors[id].root.innerHTML = quillEditorContents[id];
                    } else {
                        initQuillEditor(id, quillEditorContents[id]); 
                    }
                }

                const question1Div = document.getElementById('question1Content');
                if (question1Div) {
                    question1Div.innerHTML = question1.replace(/```html|```/g, '').trim();
                }
                
                const question2Div = document.getElementById('question2Content');
                if (question2Div) {
                     question2Div.innerHTML = question2.replace(/```html|```/g, '').trim();
                }
                
                loadingElement.style.display = 'none'; 
            } catch (error) {
                console.error('Error generating content:', error);
                alert('ì½˜í…ì¸  ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                loadingElement.style.display = 'none';
            }
        }
        
        async function callGeminiAPI(prompt, apiKeyVal) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${apiKeyVal}`; 
            const requestData = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { temperature: 0.1, maxOutputTokens: 8192 } 
            };
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestData)
            });
            if (!response.ok) { 
                const errorText = await response.text();
                throw new Error(`API í˜¸ì¶œ ì‹¤íŒ¨ (${response.status}): ${errorText}`);
            }
            const data = await response.json();
            if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                console.error("Invalid API response structure:", data);
                throw new Error('APIì—ì„œ ìœ íš¨í•œ ì‘ë‹µì„ ë°›ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
            }
            return data.candidates[0].content.parts[0].text; 
        }
        async function generateKoreanInterpretation(englishText, apiKeyVal) {
            const prompt = `ë‹¤ìŒ ì˜ì–´ í…ìŠ¤íŠ¸ë¥¼ í•œêµ­ì˜ ê³ ë“±í•™ìƒë“¤ì´ ì´í•´í•˜ê¸° ì‰½ë„ë¡ ìì—°ìŠ¤ëŸ¬ìš´ í•œêµ­ì–´ë¡œ ì˜ì—­í•´ì£¼ì„¸ìš”. ê° ë¬¸ì¥ì˜ ì˜ë¯¸ë¥¼ ì •í™•íˆ ì „ë‹¬í•˜ë˜, ì „ì²´ì ì¸ íë¦„ì´ ë¶€ë“œëŸ½ë„ë¡ ì‘ì„±í•´ì£¼ì„¸ìš”. ì „ë¬¸ì ì¸ ìš©ì–´ëŠ” ì‰½ê²Œ í’€ì–´ì„œ ì„¤ëª…í•˜ê³ , í•„ìš”í•œ ê²½ìš° ì˜ˆì‹œë¥¼ ë“¤ì–´ ì´í•´ë¥¼ ë„ì™€ì£¼ì„¸ìš”. ê²°ê³¼ëŠ” HTML ë‹¨ë½(<p>) íƒœê·¸ë¡œ ê°ì‹¸ì£¼ì„¸ìš”.\n\nì˜ì–´ ì§€ë¬¸:\n${englishText}`;
            return await callGeminiAPI(prompt, apiKeyVal);
        }
        async function generateTopics(englishText, apiKeyVal) {
            const prompt = `ë‹¤ìŒ ì˜ì–´ ì§€ë¬¸ì„ ë¶„ì„í•˜ê³  í•µì‹¬ ì£¼ì œë¥¼ ì˜ì–´ì™€ í•œêµ­ì–´ë¡œ ê°ê° ì¶”ì¶œí•´ì£¼ì„¸ìš”. ì£¼ì œëŠ” ì§€ë¬¸ì˜ í•µì‹¬ ë‚´ìš©ì„ ê°„ê²°í•˜ê³  ëª…í™•í•˜ê²Œ ë‚˜íƒ€ë‚´ì•¼ í•©ë‹ˆë‹¤. JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•´ì£¼ì„¸ìš” (ì˜ˆ: {"english": "Topic in English", "korean": "ì£¼ì œ í•œêµ­ì–´ ë²„ì „"}).\n\nì˜ì–´ ì§€ë¬¸:\n${englishText}`;
            const response = await callGeminiAPI(prompt, apiKeyVal);
            let cleaned = response.replace(/```json|```/g, '').trim(); 
            try {
                const jsonMatch = cleaned.match(/{[\s\S]*}/); 
                if (jsonMatch) { cleaned = jsonMatch[0]; }
                return JSON.parse(cleaned);
            } catch (e) { 
                console.error('Failed to parse topic JSON:', e, cleaned);
                const engMatch = cleaned.match(/"english"\s*:\s*"([^"]+)"/i);
                const korMatch = cleaned.match(/"korean"\s*:\s*"([^"]+)"/i);
                return { english: engMatch ? engMatch[1] : "Topic extraction failed.", korean: korMatch ? korMatch[1] : "ì£¼ì œ ì¶”ì¶œ ì‹¤íŒ¨" };
            }
        }
        async function generateQuestion1(englishText, apiKeyVal) {
            const prompt = `Based on the following English passage, create a multiple-choice English question appropriate for high school students.
The question should test their understanding of the main idea or specific details of the passage.

Output everything in a single, valid HTML block.
The HTML block MUST contain:
1.  The question itself, enclosed in a <p> tag.
2.  Exactly five multiple-choice options. These options MUST be presented as an HTML unordered list (<ul>). Each option MUST be an <li> element. Inside each <li> element, YOU MUST include the option label (e.g., "â‘ ", "â‘¡", "â‘¢", "â‘£", "â‘¤") followed by the option text. For example: \`<li>â‘  This is the first option.</li>\`
3.  The correct answer, clearly indicated in Korean (e.g., "<p><strong>ì •ë‹µ: â‘¢</strong></p>").
4.  A brief explanation for the answer in Korean, enclosed in a <p> tag.

Here is an EXACT example of the required HTML structure for the entire output:
\`\`\`html
<p>What is the primary color of the sky on a sunny day?</p>
<ul>
  <li>â‘  Red</li>
  <li>â‘¡ Green</li>
  <li>â‘¢ Blue</li>
  <li>â‘£ Yellow</li>
  <li>â‘¤ Orange</li>
</ul>
<p><strong>ì •ë‹µ: â‘¢</strong></p>
<p>ë§‘ì€ ë‚  í•˜ëŠ˜ì˜ ì£¼ëœ ìƒ‰ì€ íŒŒë€ìƒ‰ì…ë‹ˆë‹¤. ì´ëŠ” ë ˆì¼ë¦¬ ì‚°ë€ í˜„ìƒ ë•Œë¬¸ì…ë‹ˆë‹¤.</p>
\`\`\`

Passage:
${englishText}`;
            return await callGeminiAPI(prompt, apiKeyVal);
        }
        async function generateQuestion2(englishText, apiKeyVal) {
            const prompt = `Based on the following English passage, create a "fill-in-the-blanks" type multiple-choice question in English for high school students.
The question should present a summary sentence of the passage (or a key sentence from it) with two blanks, (A) and (B).
Each multiple-choice option should be a pair of words or short phrases that could fit into blanks (A) and (B) respectively.

Output everything in a single, valid HTML block.
The HTML block MUST contain:
1.  The question instruction as a paragraph.
2.  The summary sentence with blanks (A) and (B) clearly marked (e.g., using <i>(A)</i> and <i>(B)</i>), enclosed in a <p> tag.
3.  Exactly five multiple-choice options. These options MUST be presented as an HTML unordered list (<ul>). Each option MUST be an <li> element. Inside each <li> element, YOU MUST include the option label (e.g., "â‘ ", "â‘¡", "â‘¢", "â‘£", "â‘¤") followed by the (A) and (B) filler words/phrases. For example: \`<li>â‘  (A) jumps - (B) dog</li>\`
4.  The correct answer, clearly indicated in Korean (e.g., "<p><strong>ì •ë‹µ: â‘ </strong></p>").
5.  A brief explanation for the answer in Korean, also as a paragraph.

Here is an EXACT example of the required HTML structure for the entire output:
\`\`\`html
<p>Which pair of words best completes the blanks (A) and (B)?</p>
<p><i>The quick brown fox <i>(A)</i> over the lazy <i>(B)</i>.</i></p>
<ul>
  <li>â‘  (A) jumps - (B) dog</li>
  <li>â‘¡ (A) leaped - (B) cat</li>
  <li>â‘¢ (A) skipped - (B) log</li>
  <li>â‘£ (A) ran - (B) frog</li>
  <li>â‘¤ (A) hopped - (B) mat</li>
</ul>
<p><strong>ì •ë‹µ: â‘ </strong></p>
<p>ê°ˆìƒ‰ ì—¬ìš°ëŠ” ê²Œìœ¼ë¥¸ ê°œ ìœ„ë¡œ ì í”„í•©ë‹ˆë‹¤.</p>
\`\`\`

Passage:
${englishText}`;
            return await callGeminiAPI(prompt, apiKeyVal);
        }
        async function generateLiteralTranslation(englishText, apiKeyVal) {
            const prompt = `ë‹¤ìŒ ì˜ì–´ ì§€ë¬¸ì„ ë¬¸ì¥ë³„ë¡œ ë‚˜ëˆ„ì–´, ê° ì˜ì–´ ë¬¸ì¥ ë°”ë¡œ ì•„ë˜ì— í•œêµ­ì–´ ì§ì—­ì„ ì œê³µí•´ì£¼ì„¸ìš”. ê° ì˜ì–´ ë¬¸ì¥ê³¼ ê·¸ì— í•´ë‹¹í•˜ëŠ” í•œêµ­ì–´ ì§ì—­ì€ í•˜ë‚˜ì˜ ìŒìœ¼ë¡œ ì·¨ê¸‰í•©ë‹ˆë‹¤. ê²°ê³¼ëŠ” HTML í˜•ì‹ìœ¼ë¡œ, ê° ì˜ì–´-í•œêµ­ì–´ ìŒì„ <p> íƒœê·¸ë¡œ ê°ì‹¸ê³ , ì˜ì–´ ì›ë¬¸ì€ <b> íƒœê·¸ë¡œ ê°•ì¡°í•˜ë©°, í•œêµ­ì–´ ì§ì—­ê³¼ <br>ë¡œ êµ¬ë¶„í•´ì£¼ì„¸ìš”.\n\nì˜ì–´ ì§€ë¬¸:\n${englishText}`;
            return await callGeminiAPI(prompt, apiKeyVal);
        }
        
        function getCurrentTextForExport() { 
            const unitChoice = unitSelector.value;
            const sectionChoice = sectionSelector.value;
            const paragraphChoice = paragraphSelector.value;
            let currentText = ""; 

            const mainEditor = activeQuillEditors['englishPassageContent']; 

            if (unitChoice === "all") { 
                currentText = mainEditor ? mainEditor.root.innerHTML : window.uploadedEnglishText; 
            } else {
                const selectedUnit = parsedUnits.find(unit => unit.unitTitle === unitChoice);
                if (selectedUnit) {
                    if (sectionChoice === "unit_full_content") {
                        currentText = selectedUnit.unitTitle + "\n" + selectedUnit.unitContentWithoutTitle;
                    } else {
                        let targetSectionData = null;
                        if (sectionChoice === "grammar" && selectedUnit.grammarSection) {
                            targetSectionData = selectedUnit.grammarSection;
                        } else if (sectionChoice === "reading" && selectedUnit.readingSection) {
                            targetSectionData = selectedUnit.readingSection;
                        }

                        if (targetSectionData) {
                            if (paragraphChoice === "section_full_content" || !targetSectionData.paragraphs || targetSectionData.paragraphs.length === 0) {
                                currentText = targetSectionData.fullText;
                            } else {
                                const selectedPara = targetSectionData.paragraphs.find(p => p.id === paragraphChoice);
                                currentText = selectedPara ? selectedPara.text : targetSectionData.fullText; 
                            }
                        } else { 
                             currentText = selectedUnit.unitTitle + "\n" + selectedUnit.unitContentWithoutTitle; 
                        }
                    }
                } else { 
                     currentText = mainEditor ? mainEditor.root.innerHTML : window.uploadedEnglishText;
                }
            }
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = currentText; 
            return tempDiv.textContent || tempDiv.innerText || "";
        }
        
        function getEditorContentById(editorId) { 
            if (NON_QUILL_CONTENT_IDS.includes(editorId)) {
                const el = document.getElementById(editorId);
                return el ? el.innerHTML : "ë‚´ìš© ì—†ìŒ";
            }
            if (activeQuillEditors[editorId]) {
                return activeQuillEditors[editorId].root.innerHTML; 
            }
            const el = document.getElementById(editorId); 
            return el ? el.innerHTML : "ë‚´ìš© ì—†ìŒ"; 
        }


        // MS Wordë¡œ ë‚´ë³´ë‚´ê¸° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        document.getElementById('exportButtonType3').addEventListener('click', function() { exportToWord('type3');});
        document.getElementById('exportButtonType1').addEventListener('click', function() { exportToWord('type1');});
        document.getElementById('exportButtonType2').addEventListener('click', function() { exportToWord('type2');});

        // MS Wordë¡œ ë‚´ë³´ë‚´ê¸° í•¨ìˆ˜ (docx.js ì‚¬ìš©)
        function exportToWord(noteType) {
            try { 
                const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel, Table, TableRow, TableCell, BorderStyle, PageBreak, WidthType, ShadingType, convertInchesToTwip } = docx;
                
                function rgbToHex(rgbString) {
                    if (!rgbString) return undefined;
                    if (rgbString.startsWith('#')) return rgbString.substring(1);
                    if (!rgbString.startsWith('rgb')) return undefined;
                    const rgb = rgbString.match(/\d+/g);
                    if (!rgb || rgb.length < 3) return undefined;
                    return ((1 << 24) + (parseInt(rgb[0]) << 16) + (parseInt(rgb[1]) << 8) + parseInt(rgb[2])).toString(16).slice(1).toUpperCase();
                }

                function htmlToDocxElements(htmlContent) {
                    if (!htmlContent || typeof htmlContent !== 'string') return [new Paragraph({text: "ë‚´ìš© ì—†ìŒ", style: 'Paperlogy'})];
                    
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = htmlContent;
                    
                    const finalDocxElements = []; 

                    function parseNodeRecursive(node, currentStyle = {}, listInfo = null) {
                        const elements = []; 
                        const baseFont = currentStyle.font || 'Paperlogy'; 

                        if (node.nodeType === Node.TEXT_NODE) {
                            if (node.textContent && node.textContent.trim() !== '') { 
                                const textRunOptions = { text: node.textContent, font: baseFont };
                                if (currentStyle.bold) textRunOptions.bold = true;
                                if (currentStyle.italics) textRunOptions.italics = true;
                                if (currentStyle.underline) textRunOptions.underline = {};
                                if (currentStyle.strike) textRunOptions.strike = true;
                                if (currentStyle.color) textRunOptions.color = currentStyle.color;
                                if (currentStyle.size) textRunOptions.size = currentStyle.size;
                                if (currentStyle.shading) textRunOptions.shading = currentStyle.shading;
                                if (currentStyle.superScript) textRunOptions.superScript = true;
                                if (currentStyle.subScript) textRunOptions.subScript = true;
                                return [new TextRun(textRunOptions)]; 
                            } else if (node.textContent) { 
                                return [new TextRun({text: node.textContent, font: baseFont})];
                            }
                            return [];
                        }

                        if (node.nodeType === Node.ELEMENT_NODE) {
                            const tagName = node.tagName.toLowerCase();
                            const newStyle = { ...currentStyle }; 
                            if (!newStyle.font) newStyle.font = 'Paperlogy';

                            if (['strong', 'b'].includes(tagName)) newStyle.bold = true;
                            if (['em', 'i'].includes(tagName)) newStyle.italics = true;
                            if (tagName === 'u') newStyle.underline = true;
                            if (['s', 'strike', 'del'].includes(tagName)) newStyle.strike = true;
                            if (tagName === 'sup') newStyle.superScript = true;
                            if (tagName === 'sub') newStyle.subScript = true;

                            if (node.style.fontWeight === 'bold' || parseInt(node.style.fontWeight) >= 700) newStyle.bold = true;
                            if (node.style.fontStyle === 'italic') newStyle.italics = true;
                            if (node.style.textDecorationLine) {
                                if (node.style.textDecorationLine.includes('underline')) newStyle.underline = true;
                                if (node.style.textDecorationLine.includes('line-through')) newStyle.strike = true;
                            }
                            if (node.style.color) newStyle.color = rgbToHex(node.style.color);
                            if (node.style.backgroundColor && node.style.backgroundColor !== 'rgba(0, 0, 0, 0)' && node.style.backgroundColor !== 'transparent') {
                                newStyle.shading = { type: ShadingType.CLEAR, fill: rgbToHex(node.style.backgroundColor), color: "auto" };
                            }
                            if (node.style.fontFamily) { 
                                newStyle.font = node.style.fontFamily.split(',')[0].trim().replace(/['"]/g, '');
                            }
                            if (node.style.fontSize) {
                                const sizeMatch = node.style.fontSize.match(/([\d.]+)(px|pt)/);
                                if (sizeMatch) {
                                    const value = parseFloat(sizeMatch[1]);
                                    if (sizeMatch[2] === 'pt') newStyle.size = Math.round(value * 2);
                                    else if (sizeMatch[2] === 'px') newStyle.size = Math.round(value * 0.75 * 2);
                                }
                            }
                            
                            node.classList.forEach(cls => {
                                if (cls.startsWith('ql-font-')) {
                                    const fontName = cls.substring('ql-font-'.length);
                                    const fontMapping = { 'paperlogy': 'Paperlogy', 'malgun-gothic': "Malgun Gothic", 'dotum': "Dotum", 'gulim': "Gulim", 'batang': "Batang", 'gungsuh': "Gungsuh", 'arial': 'Arial', 'comic-sans': 'Comic Sans MS', 'courier-new': 'Courier New', 'georgia': 'Georgia', 'helvetica': 'Helvetica', 'lucida-grande': 'Lucida Grande', 'tahoma': 'Tahoma', 'times-new-roman': 'Times New Roman', 'trebuchet-ms': 'Trebuchet MS', 'verdana': 'Verdana' };
                                    newStyle.font = fontMapping[fontName] || fontName.replace(/-/g, ' ');
                                } else if (cls.startsWith('ql-size-')) {
                                    const sizeName = cls.substring('ql-size-'.length);
                                    if (sizeName === 'small') newStyle.size = Math.round(10 * 2);
                                    else if (sizeName === 'large') newStyle.size = Math.round(18 * 2);
                                    else if (sizeName === 'huge') newStyle.size = Math.round(32 * 2);
                                }
                            });

                            if (['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre'].includes(tagName)) {
                                const paragraphChildren = [];
                                Array.from(node.childNodes).forEach(child => {
                                    paragraphChildren.push(...parseNodeRecursive(child, { ...newStyle }, listInfo)); 
                                });

                                const paragraphOptions = { children: paragraphChildren.length > 0 ? paragraphChildren : [new TextRun({font: newStyle.font || 'Paperlogy'})], style: newStyle.font || 'Paperlogy' }; 

                                let alignment = AlignmentType.LEFT;
                                if (node.classList.contains('ql-align-center') || node.style.textAlign === 'center') alignment = AlignmentType.CENTER;
                                else if (node.classList.contains('ql-align-right') || node.style.textAlign === 'right') alignment = AlignmentType.RIGHT;
                                else if (node.classList.contains('ql-align-justify') || node.style.textAlign === 'justify') alignment = AlignmentType.JUSTIFIED;
                                paragraphOptions.alignment = alignment;

                                if (tagName.startsWith('h')) {
                                    const level = parseInt(tagName.substring(1));
                                    if (level >= 1 && level <= 6) paragraphOptions.heading = HeadingLevel[`HEADING_${level}`];
                                } else if (node.classList.contains('ql-header')) { 
                                    const headerLevel = parseInt(node.getAttribute('value')) || (node.classList.contains('ql-header-1') ? 1 : (node.classList.contains('ql-header-2') ? 2 : 0));
                                    if (headerLevel === 1) paragraphOptions.heading = HeadingLevel.HEADING_1;
                                    else if (headerLevel === 2) paragraphOptions.heading = HeadingLevel.HEADING_2;
                                }
                                
                                for (let i = 1; i <= 8; i++) {
                                    if (node.classList.contains(`ql-indent-${i}`)) {
                                        paragraphOptions.indent = { left: convertInchesToTwip(0.5 * i) };
                                        break;
                                    }
                                }

                                if (tagName === 'blockquote') {
                                    paragraphOptions.indent = { ...paragraphOptions.indent, left: convertInchesToTwip( (paragraphOptions.indent?.leftInTwips || 0)/convertInchesToTwip(1) + 0.5 ) }; 
                                }

                                if (tagName === 'pre' || node.classList.contains('ql-syntax')) {
                                    const codeBlockStyle = { font: "Courier New", size: Math.round(10 * 2) };
                                    const codeRuns = [];
                                    Array.from(node.childNodes).forEach(child => { 
                                        codeRuns.push(...parseNodeRecursive(child, { ...newStyle, ...codeBlockStyle }, listInfo));
                                    });
                                    paragraphOptions.children = codeRuns.length > 0 ? codeRuns : [new TextRun({font: "Courier New"})];
                                    paragraphOptions.shading = { type: ShadingType.CLEAR, fill: "F0F0F0", color: "auto" }; 
                                }
                                
                                if (listInfo) {
                                    paragraphOptions.numbering = {
                                        reference: listInfo.type === 'ol' ? "custom-numbering" : "custom-bullet",
                                        level: listInfo.level
                                    };
                                }
                                elements.push(new Paragraph(paragraphOptions));

                            } else if (tagName === 'ul' || tagName === 'ol') {
                                const currentListLevel = listInfo ? listInfo.level + 1 : 0;
                                Array.from(node.children).forEach(liNode => { 
                                    if (liNode.tagName.toLowerCase() === 'li') {
                                        Array.from(liNode.childNodes).forEach(childOfLi => {
                                            elements.push(...parseNodeRecursive(childOfLi, { ...newStyle }, { type: tagName, level: currentListLevel }));
                                        });
                                    }
                                });
                            } else if (tagName === 'table') {
                                const tableRows = [];
                                const trNodes = Array.from(node.querySelectorAll(':scope > tbody > tr, :scope > tr'));
                                trNodes.forEach(trNode => {
                                    const tableCells = [];
                                    const tdNodes = Array.from(trNode.querySelectorAll(':scope > td, :scope > th'));
                                    tdNodes.forEach(tdNode => {
                                        const cellChildren = [];
                                        Array.from(tdNode.childNodes).forEach(cellChildNode => {
                                            cellChildren.push(...parseNodeRecursive(cellChildNode, {font: newStyle.font || 'Paperlogy'}, null)); 
                                        });
                                        
                                        const finalCellChildren = [];
                                        let currentRuns = [];
                                        cellChildren.forEach(el => {
                                            if (el instanceof TextRun) {
                                                currentRuns.push(el);
                                            } else { 
                                                if (currentRuns.length > 0) {
                                                    finalCellChildren.push(new Paragraph({children: currentRuns, style: newStyle.font || 'Paperlogy'}));
                                                    currentRuns = [];
                                                }
                                                finalCellChildren.push(el);
                                            }
                                        });
                                        if (currentRuns.length > 0) {
                                            finalCellChildren.push(new Paragraph({children: currentRuns, style: newStyle.font || 'Paperlogy'}));
                                        }

                                        const cellOptions = { children: finalCellChildren.length > 0 ? finalCellChildren : [new Paragraph({style: newStyle.font || 'Paperlogy'})] };
                                        if (tdNode.style.backgroundColor && tdNode.style.backgroundColor !== 'rgba(0, 0, 0, 0)' && tdNode.style.backgroundColor !== 'transparent') {
                                            cellOptions.shading = { type: ShadingType.CLEAR, fill: rgbToHex(tdNode.style.backgroundColor), color: "auto" };
                                        }
                                        tableCells.push(new TableCell(cellOptions));
                                    });
                                    if (tableCells.length > 0) tableRows.push(new TableRow({ children: tableCells }));
                                });
                                if (tableRows.length > 0) elements.push(new Table({ rows: tableRows, width: {size: 100, type: WidthType.PERCENTAGE} }));
                            
                            } else if (tagName === 'br') {
                                return [new TextRun({break:1, font: newStyle.font || 'Paperlogy'})]; 
                            }
                            else { 
                                const inlineRuns = [];
                                Array.from(node.childNodes).forEach(child => {
                                    inlineRuns.push(...parseNodeRecursive(child, { ...newStyle }, listInfo));
                                });
                                return inlineRuns; 
                            }
                        }
                        return elements; 
                    }
                    
                    Array.from(tempDiv.childNodes).forEach(childNode => {
                        const processedElements = parseNodeRecursive(childNode, {font: 'Paperlogy'}); 
                        let currentRuns = [];
                        processedElements.forEach(el => {
                            if (el instanceof TextRun) {
                                currentRuns.push(el);
                            } else { 
                                if (currentRuns.length > 0) {
                                    finalDocxElements.push(new Paragraph({children: currentRuns, style: 'Paperlogy'}));
                                    currentRuns = [];
                                }
                                finalDocxElements.push(el);
                            }
                        });
                        if (currentRuns.length > 0) {
                            finalDocxElements.push(new Paragraph({children: currentRuns, style: 'Paperlogy'}));
                        }
                    });
                    
                    if (finalDocxElements.length === 0) {
                        if (tempDiv.innerHTML.trim() === "" || tempDiv.innerHTML.toLowerCase().trim() === "<p><br></p>") {
                             return [new Paragraph({text: "", style: 'Paperlogy'})]; 
                        }
                    }
                    return finalDocxElements.length > 0 ? finalDocxElements : [new Paragraph({text: "", style: 'Paperlogy'})];
                }


                // ë¬¸ì„œ ì œëª© ì„¤ì •
                let docChildren = [
                    new Paragraph({ text: `English Lesson Note (${noteType})`, heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER, style: 'Paperlogy' }),
                    new Paragraph({ text: " ", style: 'Paperlogy' }), // ê³µë°± ë‹¨ë½
                ];

                // ë…¸íŠ¸ íƒ€ì…ë³„ ë‚´ìš© êµ¬ì„±
                if (noteType === 'type1') {
                    docChildren.push(new Paragraph({ text: "ì˜ì–´ ì§€ë¬¸", heading: HeadingLevel.HEADING_3, style: 'Paperlogy' }));
                    docChildren.push(...htmlToDocxElements(getEditorContentById('type1EnglishPassageContent')));
                } else if (noteType === 'type2') {
                    docChildren.push(new Paragraph({ text: "í•œì¤„ í•´ì„ (ì˜ì–´ ì›ë¬¸ + ì§ì—­)", heading: HeadingLevel.HEADING_3, style: 'Paperlogy' }));
                    const type2Html = getEditorContentById('type2LiteralTranslationContent'); 
                    docChildren.push(...htmlToDocxElements(type2Html)); 
                } else if (noteType === 'type3') {
                    const englishPassageDocx = htmlToDocxElements(getEditorContentById('englishPassageContent'));
                    const koreanInterpretationDocx = htmlToDocxElements(getEditorContentById('koreanInterpretationContent'));
                    const topicEnglishDocx = htmlToDocxElements(getEditorContentById('topicEnglishContent'));
                    const topicKoreanDocx = htmlToDocxElements(getEditorContentById('topicKoreanContent'));
                    const question1Docx = htmlToDocxElements(getEditorContentById('question1Content'));
                    const question2Docx = htmlToDocxElements(getEditorContentById('question2Content'));
                    const literalTableDocx = htmlToDocxElements(getEditorContentById('literalTableContent')); 
                    const englishOnlyDocx = htmlToDocxElements(getEditorContentById('englishOnlyContent'));

                    const mainTable = new Table({
                        width: { size: 100, type: WidthType.PERCENTAGE },
                        columnWidths: [4800, 4800], 
                        rows: [
                            new TableRow({ 
                                children: [
                                    new TableCell({ 
                                        children: [ new Paragraph({ text: "ì˜ì–´ ì§€ë¬¸ (ì„ íƒëœ ë‚´ìš©)", heading: HeadingLevel.HEADING_3, style: 'Paperlogy' }), ...englishPassageDocx ],
                                        borders: { top: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, bottom: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, left: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, right: { style: BorderStyle.SINGLE, size: 6, color: "auto" } },
                                    }),
                                    new TableCell({ 
                                        children: [
                                            new Paragraph({ text: "ì£¼ì œ (ì˜ì–´)", heading: HeadingLevel.HEADING_3, style: 'Paperlogy' }), ...topicEnglishDocx,
                                            new Paragraph({ text: " ", style: 'Paperlogy' }), 
                                            new Paragraph({ text: "ì£¼ì œ (í•œêµ­ì–´)", heading: HeadingLevel.HEADING_3, style: 'Paperlogy' }), ...topicKoreanDocx
                                        ],
                                        borders: { top: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, bottom: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, left: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, right: { style: BorderStyle.SINGLE, size: 6, color: "auto" } },
                                    }),
                                ]
                            }),
                            new TableRow({ 
                                children: [
                                    new TableCell({ 
                                        children: [ new Paragraph({ text: "í•œêµ­ì–´ ì˜ì—­", heading: HeadingLevel.HEADING_3, style: 'Paperlogy' }), ...koreanInterpretationDocx ],
                                        borders: { top: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, bottom: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, left: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, right: { style: BorderStyle.SINGLE, size: 6, color: "auto" } },
                                    }),
                                    new TableCell({ 
                                        children: [
                                            new Paragraph({ text: "Question 1", heading: HeadingLevel.HEADING_3, style: 'Paperlogy' }), ...question1Docx,
                                            new Paragraph({ text: " ", style: 'Paperlogy' }), 
                                            new Paragraph({ text: "Question 2", heading: HeadingLevel.HEADING_3, style: 'Paperlogy' }), ...question2Docx
                                        ],
                                        borders: { top: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, bottom: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, left: { style: BorderStyle.SINGLE, size: 6, color: "auto" }, right: { style: BorderStyle.SINGLE, size: 6, color: "auto" } },
                                    }),
                                ]
                            }),
                        ]
                    });
                    docChildren.push(mainTable);
                    docChildren.push(new Paragraph({ children: [new PageBreak()], style: 'Paperlogy' })); 
                    docChildren.push(new Paragraph({ text: "ì§ì—­ (Literal Translation)", heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER, style: 'Paperlogy' }));
                    docChildren.push(...literalTableDocx); 
                    docChildren.push(new Paragraph({ children: [new PageBreak()], style: 'Paperlogy' })); 
                    docChildren.push(new Paragraph({ text: "ì˜ì–´ ì§€ë¬¸ë§Œ (ì„ íƒëœ ë‚´ìš©)", heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER, style: 'Paperlogy' }));
                    docChildren.push(...englishOnlyDocx);
                }


                // ë¬¸ì„œ ìƒì„±
                const doc = new Document({
                     numbering: { 
                        config: [
                            {
                                reference: "custom-numbering", // for <ol>
                                levels: [ // 0-indexed
                                    { level: 0, format: "decimal", text: "%1.", alignment: AlignmentType.START, style: { paragraph: { indent: { left: convertInchesToTwip(0.25), hanging: convertInchesToTwip(0.25) } } } },
                                    { level: 1, format: "lowerLetter", text: "%2)", alignment: AlignmentType.START, style: { paragraph: { indent: { left: convertInchesToTwip(0.5), hanging: convertInchesToTwip(0.25) } } } },
                                    { level: 2, format: "lowerRoman", text: "%3.", alignment: AlignmentType.START, style: { paragraph: { indent: { left: convertInchesToTwip(0.75), hanging: convertInchesToTwip(0.25) } } } },
                                ],
                            },
                            {
                                reference: "custom-bullet", // for <ul>
                                levels: [
                                    { level: 0, format: "bullet", text: "â€¢", alignment: AlignmentType.START, style: { paragraph: { indent: { left: convertInchesToTwip(0.25), hanging: convertInchesToTwip(0.25) } } } },
                                    { level: 1, format: "bullet", text: "â—¦", alignment: AlignmentType.START, style: { paragraph: { indent: { left: convertInchesToTwip(0.5), hanging: convertInchesToTwip(0.25) } } } },
                                    { level: 2, format: "bullet", text: "â–ª", alignment: AlignmentType.START, style: { paragraph: { indent: { left: convertInchesToTwip(0.75), hanging: convertInchesToTwip(0.25) } } } },
                                ]
                            }
                        ],
                    },
                    sections: [{
                        properties: {},
                        children: docChildren,
                    }],
                     styles: { // ì „ì—­ ìŠ¤íƒ€ì¼ ì •ì˜
                        paragraphStyles: [
                            {
                                id: "Paperlogy", // ìŠ¤íƒ€ì¼ ID
                                name: "Paperlogy Font Style",
                                run: {
                                    font: "Paperlogy",
                                },
                            },
                        ],
                    },
                });
                
                Packer.toBlob(doc).then(blob => {
                    saveAs(blob, `English_Lesson_Note_${noteType}.docx`);
                }).catch(err => {
                    console.error("Error creating DOCX blob:", err);
                    alert("MS Word íŒŒì¼ ìƒì„± ì¤‘ Blob ìƒì„± ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + err.message);
                });
            } catch (error) {
                console.error("Error during Word export process:", error);
                alert("MS Word íŒŒì¼ ë‚´ë³´ë‚´ê¸° ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + error.message);
            }
        }

        // Google Docsë¡œ ë‚´ë³´ë‚´ê¸° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        document.getElementById('exportGoogleDocsType3').addEventListener('click', function() { exportToGoogleDocs('type3'); });
        document.getElementById('exportGoogleDocsType1').addEventListener('click', function() { exportToGoogleDocs('type1'); });
        document.getElementById('exportGoogleDocsType2').addEventListener('click', function() { exportToGoogleDocs('type2'); });

        // Google Docsë¡œ ë‚´ë³´ë‚´ê¸° í•¨ìˆ˜ (ìƒˆ íƒ­ì— HTML í‘œì‹œ í›„ ìˆ˜ë™ ë³µì‚¬ ì•ˆë‚´)
        function exportToGoogleDocs(noteType) {
            let combinedHtml = `<div class="note-header">English Lesson Note (${noteType})</div>`;
            
            // ë…¸íŠ¸ íƒ€ì…ë³„ HTML ë‚´ìš© ì¡°í•©
            if (noteType === 'type1') {
                combinedHtml += `<div><h3>ì˜ì–´ ì§€ë¬¸</h3>${getEditorContentById('type1EnglishPassageContent')}</div>`;
            } else if (noteType === 'type2') {
                combinedHtml += `<div><h3>í•œì¤„ í•´ì„ (ì˜ì–´ ì›ë¬¸ + ì§ì—­)</h3>${getEditorContentById('type2LiteralTranslationContent')}</div>`; 
            } else if (noteType === 'type3') {
                combinedHtml += `<div style="display:flex;">`; 
                combinedHtml += `<div style="flex:1; padding-right:10px;">`; 
                combinedHtml += `<div><h3>${document.querySelector('#englishPassageSection .section-title').innerText}</h3>${getEditorContentById('englishPassageContent')}</div>`;
                combinedHtml += `<div><h3>${document.querySelector('#koreanInterpretationSection .section-title').innerText}</h3>${getEditorContentById('koreanInterpretationContent')}</div>`;
                combinedHtml += `</div>`; 
                combinedHtml += `<div style="flex:1; padding-left:10px;">`; 
                combinedHtml += `<div><h3>${document.querySelector('#topicEnglishSection .section-title').innerText}</h3>${getEditorContentById('topicEnglishContent')}</div>`;
                combinedHtml += `<div><h3>${document.querySelector('#topicKoreanSection .section-title').innerText}</h3>${getEditorContentById('topicKoreanContent')}</div>`;
                combinedHtml += `<div><h3>${document.querySelector('#question1Section .section-title').innerText}</h3>${getEditorContentById('question1Content')}</div>`;
                combinedHtml += `<div><h3>${document.querySelector('#question2Section .section-title').innerText}</h3>${getEditorContentById('question2Content')}</div>`;
                combinedHtml += `</div>`; 
                combinedHtml += `</div>`; 
                combinedHtml += `<div style="margin-top:20px;"><h3>${document.querySelector('#literalTableFullSection .section-title').innerText}</h3>${getEditorContentById('literalTableContent')}</div>`;
                combinedHtml += `<div style="margin-top:20px;"><h3>${document.querySelector('#englishOnlyFullSection .section-title').innerText}</h3>${getEditorContentById('englishOnlyContent')}</div>`;
            }

            // ê¸°ë³¸ ìŠ¤íƒ€ì¼ ë° ë³µì‚¬ ì•ˆë‚´ ë©”ì‹œì§€
            const styles = `
                <style>
                    @font-face {
                        font-family: 'Paperlogy';
                        src: url('https://cdn.jsdelivr.net/gh/fonts-archive/Paperlogy/Paperlogy.css'); 
                        font-weight: normal;
                        font-style: normal;
                    }
                    body { font-family: 'Paperlogy', 'Noto Sans KR', 'Malgun Gothic', sans-serif; padding: 40px; color: #4a3f35; background-color: #fdfaef; line-height: 1.7; }
                    h3 { color: #795548; margin-top: 20px; margin-bottom: 8px; font-weight: normal; border-bottom: 1px solid #eee0c4; padding-bottom: 5px; font-size: 1.4em;}
                    table { border-collapse: collapse; width: 100%; margin-bottom: 20px; font-size: 1rem; } 
                    th, td { border: 1px solid #e0d0b8; padding: 10px; text-align: left; vertical-align: top;}
                    th { background-color: #fff5e6; font-weight: normal; }
                    ul, ol { list-style-position: inside; padding-left: 5px; margin-top: 5px;} 
                    li { margin-bottom: 6px;}
                    .note-header { text-align: center; margin-bottom: 30px; font-weight: normal; font-size: 2.2rem; color: #5d4037; }
                    .section-title { font-weight: normal; margin-bottom: 10px; color: #795548; font-size: 1.5em; }
                    .ql-font-paperlogy { font-family: 'Paperlogy', sans-serif !important; }
                    .ql-editor p, .ql-editor li, .content p, .content li { margin-bottom: 0.75em; line-height: 1.75;}
                </style>
            `;
            const guide = `<div style='background:#fff5e6; color:#6d4c41; border:1px solid #f0e0c8; padding:15px 25px; margin-bottom:20px; border-radius:8px; font-size: 1rem;'><strong>Google Docsë¡œ ë³µì‚¬ ì•ˆë‚´:</strong> ì´ í˜ì´ì§€ì˜ ë‚´ìš©ì„ ì „ì²´ ì„ íƒ (Ctrl+A ë˜ëŠ” Cmd+A) í›„ ë³µì‚¬ (Ctrl+C ë˜ëŠ” Cmd+C)í•˜ì—¬ Google Docs ìƒˆ ë¬¸ì„œì— ë¶™ì—¬ë„£ê¸° (Ctrl+V ë˜ëŠ” Cmd+V) í•˜ì„¸ìš”. ìµœìƒì˜ ê²°ê³¼ë¥¼ ìœ„í•´ Google Docsì—ì„œ 'ì„œì‹ ì—†ì´ ë¶™ì—¬ë„£ê¸°'(Ctrl+Shift+V ë˜ëŠ” Cmd+Shift+V) ì˜µì…˜ì„ ì‚¬ìš©í•´ ë³´ì„¸ìš”.</div>`;
            const htmlToExport = `<!DOCTYPE html><html lang="ko"><head><meta charset='utf-8'><title>ìˆ˜ì—…ë…¸íŠ¸ ë‚´ìš© (${noteType})</title>${styles}</head><body>${guide}${combinedHtml}</body></html>`;
            
            // ìƒˆ íƒ­ì— HTML ë‚´ìš© ì—´ê¸°
            const win = window.open("", "_blank");
            win.document.open();
            win.document.write(htmlToExport);
            win.document.close();
        }

        // --- ì„¹ì…˜ ë“œë˜ê·¸ ì•¤ ë“œë¡­ ê¸°ëŠ¥ (3ì¢… íƒ­ ì „ìš©) ---
        let draggedItem = null; // í˜„ì¬ ë“œë˜ê·¸ ì¤‘ì¸ ì•„ì´í…œ

        document.querySelectorAll('#type3-content .section').forEach(item => { // 3ì¢… íƒ­ ë‚´ì˜ ì„¹ì…˜ë“¤ë§Œ
            item.addEventListener('dragstart', (e) => {
                // ì„¹ì…˜ ì œëª© ë¶€ë¶„ë§Œ ë“œë˜ê·¸ ê°€ëŠ¥í•˜ë„ë¡ ì œí•œ
                if (!e.target.classList.contains('section-title') && !e.target.closest('.section-title')) {
                     e.preventDefault(); // ì œëª©ì´ ì•„ë‹ˆë©´ ë“œë˜ê·¸ ë°©ì§€
                     return;
                }
                // Quill ì—ë””í„° ë‚´ë¶€ í´ë¦­ ì‹œ ë“œë˜ê·¸ ë°©ì§€ (í•´ë‹¹ ì„¹ì…˜ì´ Quill ì—ë””í„°ì¼ ê²½ìš°)
                const contentDiv = item.querySelector('.content');
                if (contentDiv && contentDiv.classList.contains('ql-container')) { // Quill ì—ë””í„°ì¸ì§€ í™•ì¸
                    if (e.target.closest('.ql-editor')) {
                        e.preventDefault();
                        return;
                    }
                }
                draggedItem = item;
                setTimeout(() => item.style.opacity = '0.5', 0); // ë“œë˜ê·¸ ì‹œ ë°˜íˆ¬ëª… íš¨ê³¼
                e.dataTransfer.effectAllowed = 'move';
            });

            item.addEventListener('dragend', () => { // ë“œë˜ê·¸ ì¢…ë£Œ ì‹œ
                setTimeout(() => {
                    if(draggedItem) draggedItem.style.opacity = '1'; // íˆ¬ëª…ë„ ë³µì›
                    draggedItem = null;
                }, 0);
            });
        });

        document.querySelectorAll('#type3-content .draggable-container').forEach(container => { // ë“œë¡­ ê°€ëŠ¥í•œ ì»¨í…Œì´ë„ˆ
            container.addEventListener('dragover', (e) => {
                e.preventDefault(); // ê¸°ë³¸ ë™ì‘ ë°©ì§€ (ë“œë¡­ í—ˆìš©)
                e.dataTransfer.dropEffect = 'move';
            });

            container.addEventListener('drop', (e) => { // ë“œë¡­ ì‹œ
                e.preventDefault();
                if (draggedItem) {
                    const target = e.target.closest('.section'); // ë“œë¡­ëœ ìœ„ì¹˜ì˜ ì„¹ì…˜
                    if (target && target.parentElement === container && target !== draggedItem) { // ê°™ì€ ì»¨í…Œì´ë„ˆ ë‚´ ë‹¤ë¥¸ ì„¹ì…˜ ìœ„/ì•„ë˜ë¡œ ì´ë™
                        const rect = target.getBoundingClientRect();
                        const offsetY = e.clientY - rect.top; // ë§ˆìš°ìŠ¤ Y ì¢Œí‘œ ê¸°ì¤€
                        if (offsetY > target.offsetHeight / 2) { // ì„¹ì…˜ì˜ ì ˆë°˜ ì•„ë˜ë©´ ë’¤ì— ì‚½ì…
                            container.insertBefore(draggedItem, target.nextSibling);
                        } else { // ì ˆë°˜ ìœ„ë©´ ì•ì— ì‚½ì…
                            container.insertBefore(draggedItem, target);
                        }
                    } else if (e.currentTarget === container) { // ì»¨í…Œì´ë„ˆì˜ ë¹ˆ ê³µê°„ì— ë“œë¡­ ì‹œ ë§¨ ë’¤ë¡œ ì´ë™
                         container.appendChild(draggedItem);
                    }
                }
            });
        });
    
    });
    </script>
</body>
</html>
